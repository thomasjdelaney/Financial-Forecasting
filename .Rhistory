test_gen <- generator(
data,
lookback = lookback,
delay = delay,
min_index = 300001,
max_index = NULL,
step = step,
batch_size = batch_size
)
# This is how many steps to draw from `val_gen`
# in order to see the whole validation set:
val_steps <- (300000 - 200001 - lookback) / batch_size
# This is how many steps to draw from `test_gen`
# in order to see the whole test set:
test_steps <- (nrow(data) - 300001 - lookback) / batch_size
# non-machine learning baseline ####
evaluate_naive_method <- function() {
batch_maes <- c()
for (step in 1:val_steps) {
c(samples, targets) %<-% val_gen()
preds <- samples[,dim(samples)[[2]],2]
mae <- mean(abs(preds - targets))
batch_maes <- c(batch_maes, mae)
}
print(mean(batch_maes))
}
tic("calculating naive loss...")
naive_loss <- evaluate_naive_method()
naive_time <- toc()
# basic machine learning baseline ####
basic_model <- keras_model_sequential() %>%
layer_flatten(input_shape = c(lookback / step, dim(data)[-1])) %>%
layer_dense(units = 32, activation = "relu") %>%
layer_dense(units = 1)
compile(basic_model, optimizer = optimizer_rmsprop(), loss = "mae")
tic("fitting basic model...")
basic_history <- fit_generator(basic_model, train_gen, steps_per_epoch = 500,
epochs = 20, validation_data = val_gen, validation_steps = val_steps)
basic_time <- toc()
plot(basic_history)
gru_dropout_model <- keras_model_sequential() %>%
layer_gru(units = 32, dropout = 0.2, recurrent_dropout = 0.2,
input_shape = list(NULL, dim(data)[[-1]])) %>%
layer_dense(units = 1)
compile(gru_dropout_model, optimizer = optimizer_rmsprop(), loss = "mae")
gru_dropout_history <- fit_generator(gru_dropout_model, train_gen, steps_per_epoch = 500,
epochs = 40, validation_data = val_gen, validation_steps = val_steps)
tic("fitting gru model with dropout...")
plot(gru_dropout_history)
gru_dropout_time <- toc()
gru_dropout_history
naive_loss
train_gen
plot(basic_history)
plot(gru_dropout_history)
plot(basic_history)
setwd("C:\Financial_Forecasting/")
setwd("C:/Financial_Forecasting/")
library(tictoc)
library(ggplot2)
library(M4comp2018)
library(forecast)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_train <- yearly_M4[1:num_train_series]
library(tictoc)
library(ggplot2)
library(M4comp2018)
library(forecast)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_train <- yearly_M4[1:num_train_series]
yearly_fin_train <- yearly_train[which(sapply(yearly_train, function(series)series$type == "Finance"))]
yearly_fin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearly_test[[1]]
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearlyfin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
yearly_fin_test <- yearlyfin_test
yearly_fin_test[[1]]
length(yearly_fin_test)
library(M4metalearning)
library(keras)
?load_model_hdf5()
level_scaled_model <- load_model_hdf5("./h5/level_scaled_gru_model.h5")
num_points_to_use <- 30
forecast_horizon_length <- 6
test_gen <- function() {
num_series <- length(yearly_fin_test)
samples <- array(0, dim = c(num_series, num_points_to_use, 1))
level_series <- array(0, dim = c(num_series, num_points_to_use))
alphas <- array(0, dim = c(num_series))
values <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
series <- yearly_fin_test[[i]]
series_sample <- tail(series$x, num_points_to_use)
sample_points <- length(series_sample)
ets_model <- ets(series_sample, model = "MNN")
level_sample <- ets_model$states[1:sample_points,1]
series_sample <- series_sample/level_sample - 1
if (sample_points < num_points_to_use) {# padding with zeros
series_sample <- c(0*1:(num_points_to_use - sample_points), series_sample)
level_sample <- c(head(level_sample, 1) + 0*1:(num_points_to_use - sample_points), level_sample)
}
samples[i,,1] <- series_sample
level_series[i,] <- level_sample
alphas[[i]] <- ets_model$par[[1]]
values[i,] <- series$xx
}
return(list(samples, level_series, alphas, values))
}
level_scaled_test <- test_gen()
c(level_scaled_samples, level_series, alphas, test_values)  %<-% test_gen()
rnn_scaled_preds <- predict(level_scaled_model, x = level_scaled_samples)
getPredictionFromLevelParams <- function(model_predictions, level_series, alpha) {
num_predictions <- length(model_predictions)
level_preds <- c(tail(level_series, 1), array(0, dim = c(num_predictions))) # prepending last level value
series_preds <- array(0, dim = c(num_predictions))
for (i in 1:num_predictions){
series_preds[[i]] <- level_preds[[i]]*(1 + model_predictions[[i]])
level_preds[[i+1]] <- level_preds[[i]]*(1 + alpha*model_predictions[[i]])
}
return(list(series_preds, tail(level_preds, num_predictions)))
}
rnn_preds <- array(0, dim = c(num_test_series, yearly_forecast_horizon_length))
level_preds <- array(0, dim = c(num_test_series, yearly_forecast_horizon_length))
for (i in 1:num_test_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
test_gen <- function() {
num_series <- length(yearly_fin_test)
samples <- array(0, dim = c(num_series, num_points_to_use, 1))
level_series <- array(0, dim = c(num_series, num_points_to_use))
alphas <- array(0, dim = c(num_series))
values <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
series <- yearly_fin_test[[i]]
series_sample <- tail(series$x, num_points_to_use)
sample_points <- length(series_sample)
ets_model <- ets(series_sample, model = "MNN")
level_sample <- ets_model$states[1:sample_points,1]
series_sample <- series_sample/level_sample - 1
if (sample_points < num_points_to_use) {# padding with zeros
series_sample <- c(0*1:(num_points_to_use - sample_points), series_sample)
level_sample <- c(head(level_sample, 1) + 0*1:(num_points_to_use - sample_points), level_sample)
}
samples[i,,1] <- series_sample
level_series[i,] <- level_sample
alphas[[i]] <- ets_model$par[[1]]
values[i,] <- series$xx
}
return(list(samples, level_series, alphas, values, num_series))
}
c(level_scaled_samples, level_series, alphas, test_values, num_series)  %<-% test_gen()
rnn_scaled_preds <- predict(level_scaled_model, x = level_scaled_samples)
getPredictionFromLevelParams <- function(model_predictions, level_series, alpha) {
num_predictions <- length(model_predictions)
level_preds <- c(tail(level_series, 1), array(0, dim = c(num_predictions))) # prepending last level value
series_preds <- array(0, dim = c(num_predictions))
for (i in 1:num_predictions){
series_preds[[i]] <- level_preds[[i]]*(1 + model_predictions[[i]])
level_preds[[i+1]] <- level_preds[[i]]*(1 + alpha*model_predictions[[i]])
}
return(list(series_preds, tail(level_preds, num_predictions)))
}
rnn_preds <- array(0, dim = c(num_test_series, yearly_forecast_horizon_length))
level_preds <- array(0, dim = c(num_test_series, yearly_forecast_horizon_length))
for (i in 1:num_test_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
c(level_scaled_samples, level_series, alphas, test_values, num_series)  %<-% test_gen()
rnn_scaled_preds <- predict(level_scaled_model, x = level_scaled_samples)
getPredictionFromLevelParams <- function(model_predictions, level_series, alpha) {
num_predictions <- length(model_predictions)
level_preds <- c(tail(level_series, 1), array(0, dim = c(num_predictions))) # prepending last level value
series_preds <- array(0, dim = c(num_predictions))
for (i in 1:num_predictions){
series_preds[[i]] <- level_preds[[i]]*(1 + model_predictions[[i]])
level_preds[[i+1]] <- level_preds[[i]]*(1 + alpha*model_predictions[[i]])
}
return(list(series_preds, tail(level_preds, num_predictions)))
}
rnn_preds <- array(0, dim = c(num_series, yearly_forecast_horizon_length))
level_preds <- array(0, dim = c(num_series, yearly_forecast_horizon_length))
for (i in 1:num_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
rnn_preds
yearly_fin_test[[166]]$xx
yearly_fin_test[[165]]$xx
yearly_fin_test[[163]]$xx
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearly_fin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
# applying the meta learning model ####
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
yearly_fin_test <- temp_holdout(yearly_fin_test)
yearly_fin_test <- THA_features(yearly_fin_test)
yearly_fin_test_data <- create_feat_classif_problem(yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
meta_test <- ensemble_forecast(meta_pred_weights, yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
yearly_fin_test_data <- create_feat_classif_problem(yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
yearly_fin_test <- THA_features(yearly_fin_test)
rm(list=ls())
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearly_fin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
# applying the meta learning model ####
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
yearly_fin_test <- temp_holdout(yearly_fin_test)
yearly_fin_test <- THA_features(yearly_fin_test)
yearly_fin_test
yearly_fin_test[[-1]]
length(yearly_fin_test)
yearly_fin_test[[2263]]
yearly_fin_test_data <- create_feat_classif_problem(yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
yearly_fin_test_data$data
dim(yearly_fin_test_data$data)
rm(list=ls())
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearly_fin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
# applying the meta learning model ####
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
yearly_fin_test <- temp_holdout(yearly_fin_test)
yearly_fin_test <- calc_forecasts(yearly_fin_test, forec_methods(), n.cores = 6)
yearly_fin_test <- THA_features(yearly_fin_test)
yearly_fin_test_data <- create_feat_classif_problem(yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
set.seed(1312)
yearly_M4 <- M4[which(sapply(M4, function(series)series$period == "Yearly"))]
yearly_forecast_horizon_length <- 6
indices <- sample(length(yearly_M4))
num_train_series <- 16000
num_val_series <- 3500
num_test_series <- 3500
yearly_test <- yearly_M4[(num_train_series+num_val_series+1):(num_train_series+num_val_series+num_test_series)]
yearly_fin_test <- yearly_test[which(sapply(yearly_test, function(series)series$type == "Finance"))]
# applying the meta learning model ####
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
yearly_fin_test <- temp_holdout(yearly_fin_test)
yearly_fin_test <- calc_forecasts(yearly_fin_test, forec_methods(), n.cores = 6)
yearly_fin_test <- THA_features(yearly_fin_test, n.cores = 6)
yearly_fin_test_data <- create_feat_classif_problem(yearly_fin_test)
meta_pred_weights <- predict_selection_ensemble(meta_learning_model, yearly_fin_test_data$data)
length(yearly_M4)
num_train_series+num_val_series+1
num_train_series+num_val_series+num_test_series
yearly_test[[23000]]
yearly_test[[22999]]
yearly_M4[[22999]]
yearly_M4[[23000]]
length(yearly_test)
length(yearly_fin_test)
loaded_test <- readRDS("./rds/augmented_M4_financial_test.rds")
loaded_test[[1]]
length(loaded_test[which(sapply(loaded_test, functon(series)series$type == "Finance")))])
loaded_test[which(sapply(loaded_test, functon(series)series$type == "Finance")))]
loaded_test[[1]]$type
loaded_test[which(sapply(loaded_test, functon(series)series$period == "Yearly")))]
loaded_test[which(sapply(loaded_test, functon(series)series$period == "Yearly"))]
loaded_test[which(sapply(loaded_test, functon(series)series$period == "Yearly")]
sapply(loaded_test, functon(series)series$period == "Yearly")
sapply(loaded_test, function(series)series$period == "Yearly")
loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly")))]
loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly"))]
length(loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly"))])
rm(list=ls())
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
set.seed(1312)
loaded_test <- readRDS("./rds/augmented_M4_financial_test.rds")
yearly_fin_test <- loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly"))]
# applying the meta learning model ####
meta_learning_model <- readRDS("./rds/M4_financial_xgboost_model.rds")
meta_preds <- as.matrix(sapply(meta_test, function(series)series$y_hat))
rm(list=ls())
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
# loading forecasted test series ####
loaded_test <- readRDS("./rds/augmented_M4_financial_test.rds")
yearly_fin_test <- loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly"))]
# applying the RNN model ####
level_scaled_model <- load_model_hdf5("./h5/level_scaled_gru_model.h5")
num_points_to_use <- 30
forecast_horizon_length <- 6
test_gen <- function() {
num_series <- length(yearly_fin_test)
samples <- array(0, dim = c(num_series, num_points_to_use, 1))
level_series <- array(0, dim = c(num_series, num_points_to_use))
alphas <- array(0, dim = c(num_series))
values <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
series <- yearly_fin_test[[i]]
series_sample <- tail(series$x, num_points_to_use)
sample_points <- length(series_sample)
ets_model <- ets(series_sample, model = "MNN")
level_sample <- ets_model$states[1:sample_points,1]
series_sample <- series_sample/level_sample - 1
if (sample_points < num_points_to_use) {# padding with zeros
series_sample <- c(0*1:(num_points_to_use - sample_points), series_sample)
level_sample <- c(head(level_sample, 1) + 0*1:(num_points_to_use - sample_points), level_sample)
}
samples[i,,1] <- series_sample
level_series[i,] <- level_sample
alphas[[i]] <- ets_model$par[[1]]
values[i,] <- series$xx
}
return(list(samples, level_series, alphas, values, num_series))
}
c(level_scaled_samples, level_series, alphas, test_values, num_series)  %<-% test_gen()
rnn_scaled_preds <- predict(level_scaled_model, x = level_scaled_samples)
getPredictionFromLevelParams <- function(model_predictions, level_series, alpha) {
num_predictions <- length(model_predictions)
level_preds <- c(tail(level_series, 1), array(0, dim = c(num_predictions))) # prepending last level value
series_preds <- array(0, dim = c(num_predictions))
for (i in 1:num_predictions){
series_preds[[i]] <- level_preds[[i]]*(1 + model_predictions[[i]])
level_preds[[i+1]] <- level_preds[[i]]*(1 + alpha*model_predictions[[i]])
}
return(list(series_preds, tail(level_preds, num_predictions)))
}
rnn_preds <- array(0, dim = c(num_series, yearly_forecast_horizon_length))
level_preds <- array(0, dim = c(num_series, yearly_forecast_horizon_length))
for (i in 1:num_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
rnn_preds <- array(0, dim = c(num_series, forecast_horizon_length))
level_preds <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
sapply(yearly_fin_test, function(series)series$y_hat)
yearly_fin_test[[1]]
yearly_fin_test[[1]]$y_hat
sapply(yearly_fin_test, function(series)series$y_hat)
sapply(yearly_fin_test, function(series)series$y_hat)[[1]]
dim(sapply(yearly_fin_test, function(series)series$y_hat))
sapply(yearly_fin_test, function(series)series$y_hat)[1,]
sapply(yearly_fin_test, function(series)series$y_hat)[,1]
typeof(sapply(yearly_fin_test, function(series)series$y_hat))
as.matrix(sapply(yearly_fin_test, function(series)series$y_hat)
as.matrix(sapply(yearly_fin_test, function(series)series$y_hat))
meta_preds <- sapply(yearly_fin_test, function(series)series$y_hat)
mean(abs(rnn_preds - test_values))
dim(rnn_preds)
dim(meta_preds)
dim(t(meta_preds))
rm(list=ls())
library(tictoc)
library(keras)
library(ggplot2)
library(M4comp2018)
library(forecast)
library(M4metalearning)
# loading forecasted test series ####
loaded_test <- readRDS("./rds/augmented_M4_financial_test.rds")
yearly_fin_test <- loaded_test[which(sapply(loaded_test, function(series)series$period == "Yearly"))]
meta_preds <- t(sapply(yearly_fin_test, function(series)series$y_hat))
# applying the RNN model ####
level_scaled_model <- load_model_hdf5("./h5/level_scaled_gru_model.h5")
num_points_to_use <- 30
forecast_horizon_length <- 6
test_gen <- function() {
num_series <- length(yearly_fin_test)
samples <- array(0, dim = c(num_series, num_points_to_use, 1))
level_series <- array(0, dim = c(num_series, num_points_to_use))
alphas <- array(0, dim = c(num_series))
values <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
series <- yearly_fin_test[[i]]
series_sample <- tail(series$x, num_points_to_use)
sample_points <- length(series_sample)
ets_model <- ets(series_sample, model = "MNN")
level_sample <- ets_model$states[1:sample_points,1]
series_sample <- series_sample/level_sample - 1
if (sample_points < num_points_to_use) {# padding with zeros
series_sample <- c(0*1:(num_points_to_use - sample_points), series_sample)
level_sample <- c(head(level_sample, 1) + 0*1:(num_points_to_use - sample_points), level_sample)
}
samples[i,,1] <- series_sample
level_series[i,] <- level_sample
alphas[[i]] <- ets_model$par[[1]]
values[i,] <- series$xx
}
return(list(samples, level_series, alphas, values, num_series))
}
c(level_scaled_samples, level_series, alphas, test_values, num_series)  %<-% test_gen()
rnn_scaled_preds <- predict(level_scaled_model, x = level_scaled_samples)
getPredictionFromLevelParams <- function(model_predictions, level_series, alpha) {
num_predictions <- length(model_predictions)
level_preds <- c(tail(level_series, 1), array(0, dim = c(num_predictions))) # prepending last level value
series_preds <- array(0, dim = c(num_predictions))
for (i in 1:num_predictions){
series_preds[[i]] <- level_preds[[i]]*(1 + model_predictions[[i]])
level_preds[[i+1]] <- level_preds[[i]]*(1 + alpha*model_predictions[[i]])
}
return(list(series_preds, tail(level_preds, num_predictions)))
}
rnn_preds <- array(0, dim = c(num_series, forecast_horizon_length))
level_preds <- array(0, dim = c(num_series, forecast_horizon_length))
for (i in 1:num_series){
descaled <- getPredictionFromLevelParams(rnn_scaled_preds[i,], level_series[i,], alphas[[i]])
rnn_preds[i,] <- descaled[[1]]
level_preds[i,] <- descaled[[2]]
}
mean(abs(rnn_preds - test_values))
mean(abs(meta_preds - test_values))
yearly_fin_test[[1]]$ff
yearly_fin_test[[1]]$ff["rw_drift_forec"]
yearly_fin_test[[1]]$ff["rw_drift_forec",]
yearly_fin_test[[1]]$xx
yearly_fin_test[[1]]$ff - yearly_fin_test$xx
t(yearly_fin_test[[1]]$ff) - yearly_fin_test$xx
yearly_fin_test[[1]]$ff - yearly_fin_test$xx
